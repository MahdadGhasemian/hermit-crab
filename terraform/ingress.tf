######################## Argocd ###########################

# Namespace for ArgoCD Dashboard
resource "kubernetes_namespace" "argocd_dashboard" {
  metadata {
    name = "argocd"
  }
}

# ArgoCD Ingress Route
resource "kubernetes_manifest" "argocd_ingressroute" {
  manifest = {
    apiVersion = "traefik.io/v1alpha1"
    kind       = "IngressRoute"
    metadata = {
      name      = "argocd-server"
      namespace = "argocd"
    }
    spec = {
      entryPoints = ["websecure"]
      routes = [
        {
          kind     = "Rule"
          match    = "Host(`${var.argocd_hostname}`)"
          priority = 10
          services = [
            {
              name = "argocd-server"
              port = 80
            }
          ]
        },
        {
          kind     = "Rule"
          match    = "Host(`${var.argocd_hostname}`) && Headers(`Content-Type`, `application/grpc`)"
          priority = 11
          services = [
            {
              name   = "argocd-server"
              port   = 80
              scheme = "h2c"
            }
          ]
        }
      ]
      tls = {
        certResolver = "default"
      }
    }
  }

  depends_on = [module.argocd, kubernetes_namespace.argocd_dashboard]
}

######################## Traefik ###########################

# Namespace for Traefik Dashboard
resource "kubernetes_namespace" "traefik_dashboard" {
  metadata {
    name = "traefik-dashboard"
  }
}

# Middleware for basic authentication
resource "kubernetes_manifest" "traefik_middleware" {
  manifest = {
    apiVersion = "traefik.io/v1alpha1",
    kind       = "Middleware",
    metadata = {
      name      = "admin-auth",
      namespace = kubernetes_namespace.traefik_dashboard.metadata[0].name
    },
    spec = {
      basicAuth = {
        secret = "traefik-auth"
      }
    }
  }

  depends_on = [kubernetes_namespace.traefik_dashboard]
}

# Secret for basic authentication credentials
resource "kubernetes_manifest" "traefik_auth" {
  manifest = {
    apiVersion = "v1",
    kind       = "Secret",
    metadata = {
      name      = "traefik-auth"
      namespace = kubernetes_namespace.traefik_dashboard.metadata[0].name
    },

    data = {
      # Note: in a kubernetes secret the string (e.g. generated by htpasswd) must be base64-encoded first.
      # To create an encoded user:password pair, the following command can be used:
      # htpasswd -nb user password | openssl base64
      users = var.traefik_users_secret
    }
  }

  depends_on = [kubernetes_namespace.traefik_dashboard]
}

# IngressRoute for Traefik Dashboard
resource "kubernetes_manifest" "traefik_dashboard_ingressroute" {
  manifest = {
    apiVersion = "traefik.io/v1alpha1",
    kind       = "IngressRoute",
    metadata = {
      name      = "traefik-dashboard",
      namespace = kubernetes_namespace.traefik_dashboard.metadata[0].name
    },
    spec = {
      entryPoints = ["web", "websecure"],
      routes = [
        {
          kind  = "Rule",
          match = "Host(`${var.traefik_hostname}`)",
          services = [
            {
              name = "api@internal",
              kind = "TraefikService"
            }
          ],
          middlewares = [
            {
              name      = "admin-auth",
              namespace = kubernetes_namespace.traefik_dashboard.metadata[0].name
            }
          ]
        }
      ]
    }
  }

  depends_on = [kubernetes_manifest.traefik_auth]
}

######################## Longhorn ###########################

# Middleware for basic authentication
resource "kubernetes_manifest" "longhorn_dashboard" {
  manifest = {
    apiVersion = "traefik.io/v1alpha1",
    kind       = "Middleware",
    metadata = {
      name      = "admin-auth",
      namespace = "longhorn-system"
    },
    spec = {
      basicAuth = {
        secret = "longhorn-auth"
      }
    }
  }

  depends_on = [module.longhorn]
}

# Secret for basic authentication credentials
resource "kubernetes_manifest" "longhorn_auth" {
  manifest = {
    apiVersion = "v1",
    kind       = "Secret",
    metadata = {
      name      = "longhorn-auth"
      namespace = "longhorn-system"
    },

    data = {
      # Note: in a kubernetes secret the string (e.g. generated by htpasswd) must be base64-encoded first.
      # To create an encoded user:password pair, the following command can be used:
      # htpasswd -nb user password | openssl base64
      users = var.longhorn_users_secret
    }
  }

  depends_on = [module.longhorn]
}

# IngressRoute for Longhorn Dashboard
resource "kubernetes_manifest" "longhorn_dashboard_ingressroute" {
  manifest = {
    apiVersion = "traefik.io/v1alpha1",
    kind       = "IngressRoute",
    metadata = {
      name      = "longhorn-dashboard",
      namespace = "longhorn-system"
    },
    spec = {
      entryPoints = ["websecure"],
      routes = [
        {
          kind     = "Rule",
          match    = "Host(`${var.longhorn_hostname}`)",
          priority = 10
          services = [
            {
              name = "longhorn-frontend",
              port = 80
            }
          ],
          middlewares = [
            {
              name      = "admin-auth",
              namespace = "longhorn-system"
            }
          ]
        }
      ]
      tls = {
        certResolver = "default"
      }
    }
  }

  depends_on = [module.longhorn]
}

######################### Redis #############################

# Namespace for Redis Dashboard
resource "kubernetes_namespace" "redis_dashboard" {
  metadata {
    name = "redis"
  }
}

# Middleware for basic authentication
resource "kubernetes_manifest" "redisinsight_middleware" {
  manifest = {
    apiVersion = "traefik.io/v1alpha1",
    kind       = "Middleware",
    metadata = {
      name      = "admin-auth",
      namespace = "redis"
    },
    spec = {
      basicAuth = {
        secret = "redisinsight-auth"
      }
    }
  }

  depends_on = [kubernetes_manifest.redisinsight_auth]
}

# Secret for basic authentication credentials
resource "kubernetes_manifest" "redisinsight_auth" {
  manifest = {
    apiVersion = "v1",
    kind       = "Secret",
    metadata = {
      name      = "redisinsight-auth"
      namespace = "redis"
    },

    data = {
      # Note: in a kubernetes secret the string (e.g. generated by htpasswd) must be base64-encoded first.
      # To create an encoded user:password pair, the following command can be used:
      # htpasswd -nb user password | openssl base64
      users = var.redisinsight_users_secret
    }
  }

  depends_on = [module.redisinsight, kubernetes_namespace.redis_dashboard]
}

# Resid Ingress Route
resource "kubernetes_manifest" "redisinsight_ingressroute" {
  manifest = {
    apiVersion = "traefik.io/v1alpha1"
    kind       = "IngressRoute"
    metadata = {
      name      = "redisinsight-ingress"
      namespace = "redis"
    }
    spec = {
      entryPoints = ["websecure"]
      routes = [
        {
          kind     = "Rule"
          match    = "Host(`${var.redisinsight_hostname}`)"
          priority = 10
          services = [
            {
              name = "redisinsight-service"
              port = 80
            }
          ]
          middlewares = [
            {
              name      = "admin-auth"
              namespace = "redis"
            }
          ]
        }
      ]
      tls = {
        certResolver = "default"
      }
    }
  }

  depends_on = [module.redisinsight, kubernetes_manifest.redisinsight_middleware]
}

######################### Postgresql #############################

# Postgresql Service resource
# resource "kubernetes_manifest" "postgresql_service" {
#   manifest = {
#     apiVersion = "v1"
#     kind       = "Service"
#     metadata = {
#       name      = "postgresql-service"
#       namespace = "postgresql"
#     }
#     spec = {
#       type         = "ExternalName"
#       externalName = "postgresql.postgresql.svc.cluster.local"
#       ports = [
#         {
#           name        = "http"
#           protocol    = "TCP"
#           port        = 5432
#           target_port = 5432
#         }
#       ]
#     }
#   }

#   depends_on = [module.postgresql]
# }

# Postgresql Ingress Route
# resource "kubernetes_manifest" "postgresql_ingressroute" {
#   manifest = {
#     apiVersion = "traefik.io/v1alpha1"
#     kind       = "IngressRoute"
#     metadata = {
#       name      = "postgresql-ingress"
#       namespace = "postgresql"
#     }
#     spec = {
#       entryPoints = ["websecure"]
#       routes = [
#         {
#           kind     = "Rule"
#           match    = "Host(`${var.postgresql_hostname}`)"
#           priority = 10
#           services = [
#             {
#               name = "postgresql-service"
#               port = 5432
#             }
#           ]
#         }
#       ]
#       tls = {
#         certResolver = "default"
#       }
#     }
#   }

#   depends_on = [module.postgresql, kubernetes_manifest.postgresql_service]
# }
